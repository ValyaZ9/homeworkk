from functools import lru_cache
from collections.abc import Callable


def cache(times):
    cache = {}
    def x(func: Callable):
        def wrapper(*args, **kwargs):
            wrapper.times=times
            if not cache.get(args) and wrapper.times==0:
                func_result = func(*args, **kwargs)
                cache[args] = func_result
                return func_result
            else:
                wrapper.times -= 1
                return cache[args]

        return wrapper
    return x


def cache_lru(func: Callable) -> Callable:
    return lru_cache(func)

'In previous homework task 4, you wrote a cache function that remembers other function output value.'
'Modify it to be a parametrized decorator, so that the following code::'


@cache(times=3)
def f():
    return input('? ')


print(f())
print(f())
print(f())
print(f())
print(f())

'Would give out cached value up to `times` number only.'
'Example::'


@cache(times=2)
def f():
    return input(' ?')


print(f())
print(f())
print(f())
print(f())


@cache(times=4)
def f():
    return input(' ?')


print(f())
print(f())
print(f())
print(f())
